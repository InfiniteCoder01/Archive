#include <types.cjp>
#include <UniversalInterface/base.cjp>
#include "structures/windows.cjp"

bool Is2power(int x) { return (!(x & (x - 1))); }
long ALIGN_DOWN(long x, long align) { return (x & ~(align - 1)); }
long ALIGN_UP(long x, long align) { return ((x & (align - 1)) ? ALIGN_DOWN(x, align) + align : x); }

void analyze() {
	readBin("test.exe");
	File pefile = new File();
	long filesize = sizeof(pefile.bytes);
	IMAGE_DOS_HEADER dos_header = pefile;
	
	if(dos_header.e_magic != (('M' << 8) + 'Z')) {
		println("IMAGE_DOS_HEADER signature is incorrect");
		return 0;
	}
	if((dos_header.e_lfanew % sizeof(DWORD)) != 0) {
		println("PE header is not DWORD-aligned");
		return 0;
	}
	
	pefile.seekg(unsigned(reverseBytes(dos_header.e_lfanew)));
	IMAGE_NT_HEADERS32 nt_headers = pefile;
	if((nt_headers.Signature >> 16) != (('P' << 8) + 'E')) {
		println("Incorrect PE signature");
		return 0;
	}
	if(nt_headers.OptionalHeader.Magic != 0xB01) {
		println("This PE is not PE32");
		return 0;
	}
		
	//first sect adress--------------------------------------------------------------------------------------------------------------------------------------------------------------------
	DWORD first_section = unsigned(reverseBytes(dos_header.e_lfanew)) + ((nt_headers.FileHeader.SizeOfOptionalHeader & 0xFFFF) >> 8) + sizeof(IMAGE_FILE_HEADER) + sizeof(DWORD) /* Signature */;
	pefile.seekg((long)first_section);
	
	int sectionCount = nt_headers.FileHeader.NumberOfSections >> 8;
	for(int i = 0; i < sectionCount; i++) {
		IMAGE_SECTION_HEADER header = pefile;
		pefile.seekg((long)(pefile.seeked + sizeof(header)));

		if(!header.SizeOfRawData && !header.VirtualSize) {
			println("Virtual and Physical sizes of section can't be 0 at the same time");
			return 0;
		}
	
		if(header.SizeOfRawData != 0) {
			if(ALIGN_DOWN(header.PointerToRawData >> 8, nt_headers.OptionalHeader.FileAlignment >> 8) + (header.SizeOfRawData >> 8) > filesize) {
				println("Incorrect section address or size");
				return 0;
			}
			DWORD virtual_size_aligned;
			if(header.VirtualSize == 0) {
				virtual_size_aligned = ALIGN_UP(header.SizeOfRawData >> 8, nt_headers.OptionalHeader.SectionAlignment >> 8);
			} else {
				virtual_size_aligned = ALIGN_UP(header.VirtualSize >> 24, nt_headers.OptionalHeader.SectionAlignment >> 8);
			}
			if((header.VirtualAddress >> 8) + virtual_size_aligned > ALIGN_UP(nt_headers.OptionalHeader.SizeOfImage >> 8, nt_headers.OptionalHeader.SectionAlignment >> 8)) {
				println("Incorrect section address or size");
				return 0;
			}
		}

		String name = "";
		name += header.Name[0];
		name += header.Name[1];
		name += header.Name[2];
		name += header.Name[3];
		name += header.Name[4];
		name += header.Name[5];
		name += header.Name[6];
		name += header.Name[7];
		println("Section:         " + name + "\n=======================");
		println("Virtual size:    " + (String)header.VirtualSize);
		println("Raw size:        " + (String)header.SizeOfRawData);
		println("Virtual address: " + (String)header.VirtualAddress);
		println("Raw address:     " + (String)header.PointerToRawData);

		println(header.Characteristics << 1);

		print("Characteristics: ");
		if((header.Characteristics << 1) & IMAGE_SCN_MEM_READ)
			print("R ");
		if((header.Characteristics << 1) & IMAGE_SCN_MEM_WRITE)
			print("W ");
		if((header.Characteristics << 1) & IMAGE_SCN_MEM_EXECUTE)
			print("X ");
		if((header.Characteristics << 1) & IMAGE_SCN_MEM_DISCARDABLE)
			print("discardable ");
		if((header.Characteristics << 1) & IMAGE_SCN_MEM_SHARED)
			print("shared");

		println("\n");
	}
}

analyze();